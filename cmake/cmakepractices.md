# CMakePractice

## 0. 基础

### 重要的目录

- /usr/include: 一般放操作系统的头文件
- /usr/local/include: 通常用于放第三方库的头文件
- /usr/lib: 放操作系统的动态库
- /usr/local/lib: 放第三方库的动态库

### gcc

- include header: -I<header path>
- include lib: -L<lib path>
- compile shared lib: -shared

### commands:

- ldd <executable> : check dependencies

## 1. 介绍

- 平台，并可生成 native 编译配置文件，在 Linux/Unix 平台，生成 makefile，在苹果平台，可以生成 xcode，在 Windows 平台，可以生成 MSVC 的工程文件。 -简化编译构建过程和编译过程。Cmake 的工具链非常简单：cmake+make。
  -cmake 编写的过程实际上是编程的过程，跟以前使用 autotools 一样，不过你需要编
  写的是 CMakeLists.txt(每个目录一个)，使用的是”cmake 语言和语法”。

## 2, Quick Start with VSCode

### 2.1 Configure

#### 2.1.1 Pre-Configure Steps

- Selecting a Kit
- Selecting a Variant
- Set Up Include Paths for C++ IntelliSense, with configuration in c_cpp_properties.json

```json
      "configurationProvider": "ms-vscode.cmake-tools ",
      "compileCommands": "${workspaceFolder}/build/compile_commands.json"
```

#### 2.1.2 Run Configuration

- 相当于 cmake ..

### 2.2 Build the project

- CMAKE: BUILD (F7)

#### 2.2.1 The Default target

- default target is the “all” target (named ALL_BUILD in some generators), which will build all targets CMake has designated for a default build.

- Clicking this button will show a quick-pick for all the target CMake Tools is aware of that can be built, along with the full path to the build result that will be generated by the target:
  ![](https://vector-of-bool.github.io/docs/vscode-cmake-tools/_images/target_selector.png)

#### 2.2.2 Build the single Target

- Instead of changing the build target, one can also request to build a single target a single time. Run the CMake: Build a target command, or hit the associated hotkey (defaults to Shift+F7).

#### 2.2.3 How CMake Tools Builds

- CMake Tools builds by passing the --build flag to CMake. This flag is used as a generator-agnostic build invocation tool. CMake tools also passes --config <build-type> based on the current build type from the active variant. This instructs multi-conf build tools on what configuration they should build.

### 2.3 Clean up

- CMake Tools lets you clean the build output by running the CMake: Clean command. One can also run the CMake: Clean rebuild to quickly delete build results and run the build from scratch.

### 2.4 Debug and Launch

#### 2.4.1 Quick Debugging

- Short cut: Ctrl+F5
- Quick-debugging lets you start a debugger on a target without ever creating a launch.json.

#### 2.4.2 Debugging with CMake Tools and launch.json

- launch.json enable to include setting things like the working directory or command line arguments
- ses the cmake.launchTargetPath and cmake.launchTargetDirectory to start a debugger on the active selected launch target
- minimal example:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "(gdb) Launch",
      "type": "cppdbg",
      "request": "launch",
      // Resolved by CMake Tools:
      "program": "${command:cmake.launchTargetPath}",
      "args": [],
      "stopAtEntry": false,
      "cwd": "${workspaceFolder}",
      "environment": [
        {
          // add the directory where our target was built to the PATHs
          // it gets resolved by CMake Tools:
          "name": "PATH",
          "value": "$PATH:${command:cmake.launchTargetDirectory}"
        },
        {
          "name": "OTHER_VALUE",
          "value": "Something something"
        }
      ],
      "externalConsole": true,
      "MIMode": "gdb",
      "setupCommands": [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true
        }
      ]
    }
  ]
}
```

#### 2.4.3 Running Targets Without a Debugger

- CMake: RUN Without debugging (shift+F5)

## 3. Practice

### 3.1 case1

```
PROJECT (HELLO) #指令定义工程名称,隐式的定义了两个 cmake 变量:<projectname>_BINARY_DIR 以及<projectname>_SOURCE_DIR，
SET(SRC_LIST main.c) #SET 指令可以用来显式的定义变量
MESSAGE(STATUS "This is BINARY dir " ${HELLO_BINARY_DIR}) #终端输出用户定义的信息
MESSAGE(STATUS "This is SOURCE dir "${HELLO_SOURCE_DIR})
ADD_EXECUTABLE(hello ${SRC_LIST}) #会生成一个文件名为 hello 的可执行文件，相关的源文件是 SRC_LIST 中定义的源文件列表

指令语法:
- PROJECT(projectname [CXX] [C] [Java])
- SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])
- MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] "message to display"
- ${}:引用变量, 有一些例外，比如在 IF 控制语句，变量是直接使用变量名引用，而不需要${}
- 指令(参数 1 参数 2...): 参数使用括弧括起，参数之间使用空格或分号分开

Notes:
- 指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令
- 工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的
- SET(SRC_LIST main.c)也可以写成 SET(SRC_LIST “main.c”), 假设一个源文件的文件名是 fu nc.c(文件名中间包含了空格)。这时候就必须使用双引号，如果写成了 SET(SRC_LIST fu nc.c)，就会出现错误，提示你找不到 fu 文件和 nc.c 文件。这种情况，就必须写成:SET(SRC_LIST “fu nc.c”)
- out-of-source 外部编译: HELLO_SOURCE_DIR 指代工程路径,HELLO_BINARY_DIR 指代编译路径

```

### 3.2 Case2

```
子目录 code CMakeLists.txt:
ADD_EXECUTABLE(hello main.c)

工程目录 CMakeLists.txt：
PROJECT(HELLO)
ADD_SUBDIRECTORY(code bin2)： # 指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。

指令语法：
- SET(EXECUTABLE_OUTPUT_PATH ${<PROJECT>_BINARY_DIR}/bin) #执行二进制的输出路径为 build/bin
- SET(LIBRARY_OUTPUT_PATH ${<PROJECT>_BINARY_DIR}/lib) #和库的输出路径为 build/lib
- INSTALL(TARGETS targets...  #参数中的 TARGETS 后面跟的就是我们通过 ADD_EXECUTABLE 或者 ADD_LIBRARY 定义的目标文件，可能是可执行二进制、动态库、静态库。
 [[ARCHIVE|LIBRARY|RUNTIME]
 [DESTINATION <dir>]
 [PERMISSIONS permissions...]
 [CONFIGURATIONS
 [Debug|Release|...]]
 [COMPONENT <component>]
 [OPTIONAL]
 ] [...])

- INSTALL(FILES files... DESTINATION <dir> #普通文件的安装
 [PERMISSIONS permissions...]
 [CONFIGURATIONS [Debug|Release|...]]
 [COMPONENT <component>]
 [RENAME <name>] [OPTIONAL])
- INSTALL(PROGRAMS files... DESTINATION <dir> #非目标文件的可执行程序安装(比如脚本之类)：
 [PERMISSIONS permissions...]
 [CONFIGURATIONS [Debug|Release|...]]
 [COMPONENT <component>]
 [RENAME <name>] [OPTIONAL])
- INSTALL(DIRECTORY dirs... DESTINATION <dir> #目录的安装：
 [FILE_PERMISSIONS permissions...]
 [DIRECTORY_PERMISSIONS permissions...]
 [USE_SOURCE_PERMISSIONS]
 [CONFIGURATIONS [Debug|Release|...]]
 [COMPONENT <component>]
 [[PATTERN <pattern> | REGEX <regex>]
 [EXCLUDE] [PERMISSIONS permissions...]] [...])

- INSTALL([[SCRIPT <file>] [CODE <code>]] [...]) #SCRIPT 参数用于在安装时调用 cmake 脚本文件（也就是<abc>.cmake 文件）, CODE 参数用于执行 CMAKE 指令，必须以双引号括起来。比如：INSTALL(CODE "MESSAGE(\"Sample install message.\")")


Notes：
- 上面的例子定义了将 code 子目录加入工程，并指定编译输出(包含编译中间结果)路径为bin 目录。如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/code 目录(这个目录跟原有的 code 目录对应)，指定 bin2 目录后，相当于在编译时将 code 重命名为 bin2 bin2 目录
- 换个地方保存目标二进制: ADD_EXECUTABLE 或 ADD_LIBRARY，如果需要改变目标存放路径，就在哪里加入上述的定义
-  DESTINATION 定义了安装的路径，如果路径以/开头，那么指的是绝对路径，这时候CMAKE_INSTALL_PREFIX 其实就无效了。如果你希使用 CMAKE_INSTALL_PREFIX 来定义安装路径，就要写成相对路径，即不要以/开头，那么安装后的路径就是${CMAKE_INSTALL_PREFIX}/<DESTINATION 定义的路径>



```

### 3.3 case3-create dynamic and static library

```
工程目录 CMakeLists.txt：
PROJECT(HELLOLIB)
ADD_SUBDIRECTORY(lib)


lib目录 CMakeLists.txt：
SET(LIBHELLO_SRC hello.c)
ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})： 指定编译后target library 的输出位置
#ADD_LIBRARY(hello STATIC ${LIBHELLO_SRC}): 静态库根本没有被构建,因为 hello 作为一个 target 是不能重名的，所以，静态库构建指令无效。
ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC})
SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME "hello")
SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1) #了实现动态库版本号, VERSION 指代动态库版本，SOVERSION 指代 API 版本
INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib) #install library
INSTALL(FILES hello.h DESTINATION include/hello) # install headers

指令语法:
-  ADD_LIBRARY(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN) #指令构建动态库和静态库
-  SET_TARGET_PROPERTIES(target1 target2 ...PROPERTIES prop1 value1 prop2 value2 ...) #可以用于时构建同名的动态库和静态库，控制动态库版本
-  GET_TARGET_PROPERTY(VAR target property) # read target's property to VAR

Notes：
- SHARED，动态库， STATIC，静态库
- SET_TARGET_PROPERTIES 可以用于修改库OUTPUT_NAME, 控制动态库的版本
- INSTALL 用于安装头文件和动态库、静态库

```

### 3.4 case4: how to use dynamic and static library

```
工程目录 CMakeLists.txt

PROJECT(NEWHELLO)
ADD_SUBDIRECTORY(code4)

code CMakeLists.txt:

INCLUDE_DIRECTORIES(/tmp/t3/usr/include/hello)
LINK_DIRECTORIES(/tmp/t3/usr/lib)
ADD_EXECUTABLE(main main.cpp)
TARGET_LINK_LIBRARIES(main libhello.so)
SET(EXECUTABLE_OUTPUT_PATH ${NEWHELLO_BINARY_DIR}/bin)

指令语法:
- INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...): 向工程添加多个特定的头文件搜索路径,默认的行为是追加到当前的头文件搜索路径, 通过 AFTER 或者 BEFORE 参数，可以控制是追加还是置前
- LINK_DIRECTORIES(directory1 directory2 ...): 加入非标准的库文件搜索路径
- TARGET_LINK_LIBRARIES(target library1<debug | optimized> library2 ...): 用来为 target 添加需要链接的共享库

Notes:
- LINK_DIRECTORIES: 需要放在add_executable 之前
```

## 4. Useful variables command

### 4.1 Variables

- CMAKE_BINARY_DIR,PROJECT_BINARY_DIR,<projectname>\_BINARY_DIR: 是 out-of-source 编译，指的是工程编译发生的目录
- CMAKE_SOURCE_DIR, PROJECT_SOURCE_DIR, <projectname>\_SOURCE_DIR: 是工程顶层目录
- CMAKE_CURRENT_SOURCE_DIR: 当前处理的 CMakeLists.txt 所在的路径
- CMAKE_CURRENT_BINARY_DIR: target 编译目录,ADD_SUBDIRECTORY(src bin)可以更改这个变量的值
- CMAKE_CURRENT_LIST_FILE: 调用这个变量的 CMakeLists.txt 的完整路径
- CMAKE_CURRENT_LIST_LINE: 输出这个变量所在的 line
- EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH: 重新定义最终结果的存放目录
- PROJECT_NAME: 返回通过 PROJECT 指令定义的项目名称
- $ENV{NAME}: 调用系统的环境变量, eg: MESSAGE(STATUS "HOME dir: $ENV{HOME}")

### 4.2 switch

- BUILD_SHARED_LIBS: 个开关用来控制默认的库编译方式，如果不进行设置，使用 ADD_LIBRARY 并没有指定库类型的情况下，默认编译生成的库都是静态库

### 4.3 commands

- ADD_DEFINITIONS: C/C++编译器添加-D 定义,，参数之间用空格分割。如果你的代码中定义了#ifdef ENABLE_DEBUG #endif，这个代码块就会生效,eg:
  `ADD_DEFINITIONS(-DENABLE_DEBUG -DABC)`

- ADD_DEPENDENCIES: 定义 target 依赖的其他 target，确保在编译本 target 之前，其他的 target 已经被构建。

  - ADD_DEPENDENCIES(target-name depend-targ depend-target2 ...)

- ADD_EXECUTABLE

- ADD_LIBRARY

- ADD_SUBDIRECTORY

- ENABLE_TESTING: 用来控制 Makefile 是否构建 test 目标，涉及工程所有目录,语法很简单，没有任何参数，ENABLE_TESTING()，一般情况这个指令放在工程的主 CMakeLists.txt 中

- ADD_TEST: testname 是自定义的 test 名称，Exename 可以是构建的目标文件也可以是外部脚本等

  - ADD_TEST(testname Exename arg1 arg2 ...)
  - When you call add_test(...), CMake will not generate the tests unless enable_testing() has been called.

    ```cmake
    # My CMake setup often looks like this:

    include(CTest) # note: this adds a BUILD_TESTING which defaults to ON

    # ...

    if(BUILD_TESTING)
      add_subdirectory(tests)
    endif()
    In the tests directory:

    # setup test dependencies
    # googletest has some code they explain on how to set it up; put that here

    add_executable(MyUnitTests
        # ...
    )

    target_link_libraries(MyUnitTests gtest_main)

    add_test(MyUnitTestName MyUnitTests)

    ```

- CMAKE_MINIMUM_REQUIRED

- AUX_SOURCE_DIRECTORY: 发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表

  - AUX_SOURCE_DIRECTORY(dir VARIABLE)

- EXEC_PROGRAM: 在 CMakeLists.txt 处理过程中执行命令，并不会在生成的 Makefile 中执行。

  - EXEC_PROGRAM(Executable [directory in which to run] [ARGS <arguments to executable>]
    [OUTPUT_VARIABLE <var>] [RETURN_VALUE <var>])
    用于在指定的目录运行某个程序，通过 ARGS 添加参数，如果要获取输出和返回值，可通过
    OUTPUT_VARIABLE 和 RETURN_VALUE 分别定义两个变量.
  - examples:

  ```cmake
  EXEC_PROGRAM(ls ARGS "*.c" OUTPUT_VARIABLE LS_OUTPUT RETURN_VALUE LS_RVALUE)
  IF(not LS_RVALUE)
  MESSAGE(STATUS "ls result: " ${LS_OUTPUT})
  ENDIF(not LS_RVALUE)

  在 cmake 生成 Makefile 的过程中，就会执行 ls 命令，如果返回 0，则说明成功执行，那么就输出 ls *.c 的结果。关于 IF 语句，后面的控制指令会提到。
  ```

- FILE:

  - FILE(WRITE filename "message to write"... )
  - FILE(APPEND filename "message to write"... )
  - FILE(READ filename variable)
  - FILE(GLOB variable [RELATIVE path] [globbingexpressions]...)
  - FILE(GLOB_RECURSE variable [RELATIVE path][globbing expressions]...)
  - FILE(REMOVE [directory]...)
  - FILE(REMOVE_RECURSE [directory]...)
  - FILE(MAKE_DIRECTORY [directory]...)
  - FILE(RELATIVE_PATH variable directory file)
  - FILE(TO_CMAKE_PATH path result)
  - FILE(TO_NATIVE_PATH path result)

- INCLUDE: ，用来载入 CMakeLists.txt 文件，也用于载入预定义的 cmake 模块

- FIND:

  - FIND_FILE(<VAR> name1 path1 path2 ...): VAR 变量代表找到的文件全路径，包含文件名
  - FIND_LIBRARY(<VAR> name1 path1 path2 ...): VAR 变量表示找到的库全路径，包含库文件名
  - FIND_PATH(<VAR> name1 path1 path2 ...): VAR 变量代表包含这个文件的路径。

  ```cmake
  FIND_PATH(myHeader hello.h)
  IF(myHeader)
  INCLUDE_DIRECTORIES(${myHeader})
  ENDIF(myHeader)
  ```

  - FIND_PROGRAM(<VAR> name1 path1 path2 ...) VAR 变量代表包含这个程序的全路径。
  - FIND_PACKAGE(<name> [major.minor] [QUIET] [NO_MODULE][required|components] [componets...]]): ?
  - example:
    ```cmake
    FIND_LIBRARY(libX X11 /usr/lib)
    IF(NOT libX)
    MESSAGE(FATAL_ERROR “libX not found”)
    ENDIF(NOT libX)
    ```

### 4.4 controls

- IF:

  - IF(expression),ELSE(expression),ENDIF(expression)
  - IF(var)
  - IF(NOT var )，与上述条件相反
  - IF(var1 AND var2)，当两个变量都为真是为真
  - IF(var1 OR var2)，当两个变量其中一个为真时为真
  - IF(COMMAND cmd)，当给定的 cmd 确实是命令并可以调用是为真。
  - IF(EXISTS dir)或者 IF(EXISTS file)，当目录名或者文件名存在时为真
  - IF(file1 IS_NEWER_THAN file2)，当 file1 比 file2 新，或者 file1/file2 其中有一个不存在时为真，文件名请使用完整路径。
  - IF(IS_DIRECTORY dirname)，当 dirname 是目录时，为真。
  - IF(variable MATCHES regex)
  - IF(variable LESS number)
  - IF(variable GREATER number)
  - IF(variable EQUAL number)
  - IF(string STRLESS string)
  - IF(string STRGREATER string)
  - IF(string STREQUAL string)
  - IF(DEFINED variable)，如果变量被定义，为真。

- WHILE

  - WHILE(condition), ENDWHILE(condition)

- FOREACH

  - FOREACH(loop_var arg1 arg2 ...),ENDFOREACH(loop_var) : 列表

  ```cmake
  AUX_SOURCE_DIRECTORY(. SRC_LIST)
  FOREACH(F ${SRC_LIST})
    MESSAGE(${F})
  ENDFOREACH(F)
  ```

  - FOREACH(loop_var RANGE total), ENDFOREACH(loop_var): 范围

  ```cmake
    FOREACH(VAR RANGE 10)
    MESSAGE(${VAR})
    ENDFOREACH(VAR)
  ```

  - FOREACH(loop_var RANGE start stop [step]), NDFOREACH(loop_var): 范围和步进

  ```cmake
  FOREACH(A RANGE 5 15 3)
  MESSAGE(${A})
  ENDFOREACH(A)
  ```

## 5. Troubleshooting

- improve log level
- check log file: CMake: Open cmake tool log files
